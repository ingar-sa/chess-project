// Test for all legal moves and checks 
List of tiles 

During the check of what moves might set the players king in check,
when we check the player's king's move, we have to update the position of the tile
that contains the king so that black will look for that

for tile in list of tiles:
    tile/piece -> legal moves for the specific tile/piece 
    -> adds to hashmap of ints/tiles 






//Knight

moves<int[]> = {[1, -2], [2, -1]}

for (int[] xy : moves) {
    moves.add()
}


Create chessboard in Game
Each turn game creates a shadowcopy of chessboard 
Pass shadowboard to CheckLegalMoves
//CheckLegalMoves creates a shadowcopy of chessboard (shadowboard)
CheckLegalMoves uses MovementPatterns to manipulate shadowboard
The final hashmap of the legal moves is passed back to Game
Game uses this to update chessboard


CheckLegalMoves first creates a copy of the 2d array of the board tiles
CheckLegalMoves sends the copy to MovementPatterns to get a hashmap of all possible moves 

whitehashmap with all moves for white 

CheckLegalMoves then iterates over the hashmap and updates the 2d array for every move

CheckLegalMoves removes these moves from the hashmap:
for key, value in hashmap: b1 = [[1,2],[3,2]]
    *2d array = shadowboard
    move piece from keytile to MovementPatterns value tile:

    if piece is king:
        if king is moved to castling tile test for check at both tiles:
            castlingKingTile = update
            shadowbard orginal king
        else: 
            update king position

    update all associated atttributes
    MovementPatterns(*2d array) - for black

    for values in opposite hashmap:
        if value == white king position
            whitehashmap.remove(this value from key)
        
//Figuring out java bullshit















//Piece the player wants to move
Person clicks on a tile in GUI -> 
interface calls getTile() in PlayerMove to get tile ->
if there is a piece on the tile ->
check if piece matches player color ->
check all valid moves and attacks, then display on GUI

//Check for valid moves


private void pawnMoves(int row, int col) {
    if player color is white {
        move direction sign is 1
    }
    else {
        move direction sign = -1
    }

    int[][] validMoveCoordinates = new int[4][2];

    int moveDistance = 1;
    if (!hasMoved) moveDistance = 2;

    if white {
    check if boardTiles[row + 1][col] && boardTiles[row + 2][col] is isOccupied;
    }
    if black {
    check if boardTiles[row - 1][col] && boardTiles[row - 2][col] is isOccupied;
    }
    if (!hasMoved) {
        add row + 1 and row + 2;
    }
    else {
        add only row + 1;
    }

    //Attack

    check if boardTiles[row + 1][col + 1] and  boardTiles[row + 1][col - 1] isOccupied;
    if (true) {
        add coordinates;
    }
}

private void validKingMoves() {

}

//Move the player wants to make

if the tile that is clicked is not a valid tile -> 
    if the tile is another of the player's pieces ->
        run the "piece the player wants to move"-code
    else ->
        do nothing
         
else (if the tile is a valid move)->
    call movePiece method
    end the turn



//Method logic pseudocode
private Tile getTile(int row, int col) {
    return boardTiles[row][col]
}

private void MoveHandler() {
    Tile tileFrom = getTile(input from user interface);
    Piece piece;

    if (tile.isOccupied()) {
        piece = tile.getPiece
    }
}

private void checkMate() {
    if (no valid moves for king) ->
        for (all player in chekc's pieces) ->

}
